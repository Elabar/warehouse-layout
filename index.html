<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <script
      src="https://code.jquery.com/jquery-3.5.1.min.js"
      integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
      crossorigin="anonymous"
    ></script>
    <title>My first three.js app</title>
    <style>
      body {
        margin: 0;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from "https://unpkg.com/three/build/three.module.js";
      import { OrbitControls } from "https://unpkg.com/three/examples/jsm/controls/OrbitControls.js";
      var cells = [];
      const lanes = [
        {
          lane: "1",
          columns: [
            {
              column: "AAA",
              racks: [
                {
                  floor: 1, // total floor of the rack,
                  row: "AAA",
                },
                {
                  floor: 3, // total floor of the rack,
                  row: "AAB",
                },
                {
                  floor: 4, // total floor of the rack,
                  row: "AAC",
                },
                {
                  floor: 5, // total floor of the rack,
                  row: "AAD",
                },
              ],
            },
            {
              column: "AAB",
              racks: [
                {
                  floor: 2, // total floor of the rack,
                  row: "AAA",
                },
              ],
            },
          ],
        },
        {
          lane: "2",
          columns: [
            {
              column: "AAC",
              racks: [
                {
                  floor: 3, // total floor of the rack,
                  row: "AAA",
                },
              ],
            },
            {
              column: "AAD",
              racks: [
                {
                  floor: 4, // total floor of the rack,
                  row: "AAA",
                },
              ],
            },
          ],
        },
      ];

      let rack = [
        {
          row: "AAA",
          column: "AAA",
          floor: 1,
          lane: 2,
        },
        {
          row: "AAB",
          column: "AAA",
          floor: 1,
          lane: 2,
        },
        {
          row: "AAC",
          column: "AAA",
          floor: 1,
          lane: 2,
        },
        {
          row: "AAD",
          column: "AAA",
          floor: 3,
          lane: 2,
        },
        {
          row: "AAE",
          column: "AAA",
          floor: 3,
          lane: 2,
        },
      ];
      var drawRack = function (
        floor,
        size,
        index,
        extra,
        depthStart,
        depthEnd
      ) {
        for (let i = 1; i <= floor; i++) {
          var material = new THREE.LineBasicMaterial({
            color: 0xff0000,
            linewidth: 2,
          });
          var points = [];

          points.push(
            new THREE.Vector3(
              -size + index * size * 3,
              i * size - size,
              depthStart
            )
          );
          points.push(
            new THREE.Vector3(
              size + index * size * 3,
              i * size - size,
              depthStart
            )
          );
          points.push(
            new THREE.Vector3(
              size + index * size * 3,
              i * size - size,
              depthEnd
            )
          );
          points.push(
            new THREE.Vector3(
              -size + index * size * 3,
              i * size - size,
              depthEnd
            )
          );
          points.push(
            new THREE.Vector3(
              -size + index * size * 3,
              i * size - size,
              depthStart
            )
          );

          points.push(
            new THREE.Vector3(-size + index * size * 3, i * size, depthStart)
          );
          points.push(
            new THREE.Vector3(size + index * size * 3, i * size, depthStart)
          );
          points.push(
            new THREE.Vector3(
              size + index * size * 3,
              i * size - size,
              depthStart
            )
          );
          points.push(
            new THREE.Vector3(size + index * size * 3, i * size, depthStart)
          );
          points.push(
            new THREE.Vector3(size + index * size * 3, i * size, depthEnd)
          );
          points.push(
            new THREE.Vector3(
              size + index * size * 3,
              i * size - size,
              depthEnd
            )
          );
          points.push(
            new THREE.Vector3(
              -size + index * size * 3,
              i * size - size,
              depthEnd
            )
          );
          points.push(
            new THREE.Vector3(-size + index * size * 3, i * size, depthEnd)
          );
          points.push(
            new THREE.Vector3(-size + index * size * 3, i * size, depthStart)
          );
          points.push(
            new THREE.Vector3(-size + index * size * 3, i * size, depthEnd)
          );
          points.push(
            new THREE.Vector3(size + index * size * 3, i * size, depthEnd)
          );

          var geometry = new THREE.BufferGeometry().setFromPoints(points);
          var line = new THREE.Line(geometry, material);

          var geometry = new THREE.BoxGeometry(
            size * 2 - size * 0.1,
            size - size * 0.1,
            size - size * 0.1
          );
          var material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
          var cube = new THREE.Mesh(geometry, material);
          cube.position.x = index * size * 3;
          cube.position.y = (size - 1) * (2 * i - 1);
          cube.position.z = depthStart + 1;
          cube.userData.extra = extra;
          cube.userData.actualFloor = i;
          cells.push(cube);
          scene.add(cube);
          scene.add(line);
        }
      };

      var drawColumn = function (col, colIndex, curLane, size, laneRack, colCode) {
        let depthStart = laneRack[0];
        let depthEnd = laneRack[1];
        for (let i = 0; i < col.length; i++) {
          let extra = {
            ...col[i],
            colCode
          }
          drawRack(col[i].floor, size, i, extra, depthStart, depthEnd);
        }
      };

      var drawLane = function (lanes) {
        let curLane = 1;

        let size = 2;
        let depth = 2;
        let space = 5;
        let laneGap = size * 2 + space;

        for (let i = 0; i < lanes.length; i++) {
          lanes[i].columns.map((col, colIndex) => {
            if (colIndex == 0) {
              let laneRack = [
                (curLane - 1) * laneGap,
                (curLane - 1) * laneGap + depth,
              ];
              drawColumn(col.racks, colIndex, curLane, size, laneRack, col.column);
            } else {
              let laneRack = [
                (curLane - 1) * laneGap + depth + space,
                (curLane - 1) * laneGap + depth * 2 + space,
              ];
              drawColumn(col.racks, colIndex, curLane, size, laneRack, col.column);
            }
          });
          curLane++;
        }
      };

      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        1,
        1000
      );
      var renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.domElement.addEventListener("click", onDocumentMouseDown, true);
      var controls = new OrbitControls(camera, renderer.domElement);
      function onDocumentMouseDown(event) {
        event.preventDefault();
        var mouse = new THREE.Vector2();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        var raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);
        var intersects = raycaster.intersectObjects(cells);
        if (intersects.length > 0) {
          let code = `CHR-${intersects[0].object.userData.extra.colCode}-${intersects[0].object.userData.extra.row}-${intersects[0].object.userData.actualFloor}`
          console.log(code);
        }
      }

      function onDocumentMouseMove(event) {
        var mouse = new THREE.Vector2();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        var raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);
        var intersects = raycaster.intersectObjects(cells);
        cells.map((v, i) => {
          var material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
          cells[i].material = material;
        });
        if (intersects.length > 0) {
          $("html,body").css("cursor", "pointer");
          let first = intersects[0]
          let index = cells.findIndex(
              (e) => first.object.geometry.uuid === e.geometry.uuid
            );
            var material = new THREE.MeshBasicMaterial({ color: 0x0000ff });
            cells[index].material = material;
        } else {
          $("html,body").css("cursor", "default");
        }
      }
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      scene.add(new THREE.GridHelper(500, 10));
      drawLane(lanes);
      camera.position.z = 5;
      document.addEventListener("mousemove", onDocumentMouseMove, false);
      window.addEventListener("resize", () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      });
      var animate = function () {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      };

      animate();
    </script>
  </body>
</html>
